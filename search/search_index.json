{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"NetDaemon This is the application daemon project for Home Assistant. This project makes it possible to make automatons using the .NET Core (3.1) framework. The API uses the new nullable types and C# 8.0. Please make your self familiar with these concepts. Why a new application daemon for Home Assistant? There already exists one!? The existing appdaemon is a great software and are using python as language and ecosystem. This is for people who loves to code in the .NET core ecosystem and c#. The daemon will be supported by all supported platforms of .NET core. Pre-Alpha - Expect things to change Warning This is in pre-alpha experimental phase and expect API:s to change over time. Please use and contribute ideas for improvement or better yet PR:s. Only tested on amd64 based architectures like PC or NUC and Raspberry PI 3. Probably works on other architectures too. Will update the docs when I get confirmations from other platforms. The daemon is currently only distributed through Hassio add-on but a docker container and instruction to run locally will be provided in time. Please see the getting started documentation for setup. Info You need to restart the add-on every time you change a file. C# needs to compile the changes. Async model The application daemon are built entirely on the async model of .NET. This requires some knowledge of async/await/Tasks to use it properly. The docs will give you tips with do and don\u00b4ts around this but I strongly suggest you read the official docs. Here is a good start to read about async model.","title":"Home"},{"location":"#netdaemon","text":"This is the application daemon project for Home Assistant. This project makes it possible to make automatons using the .NET Core (3.1) framework. The API uses the new nullable types and C# 8.0. Please make your self familiar with these concepts. Why a new application daemon for Home Assistant? There already exists one!? The existing appdaemon is a great software and are using python as language and ecosystem. This is for people who loves to code in the .NET core ecosystem and c#. The daemon will be supported by all supported platforms of .NET core.","title":"NetDaemon"},{"location":"#pre-alpha-expect-things-to-change","text":"Warning This is in pre-alpha experimental phase and expect API:s to change over time. Please use and contribute ideas for improvement or better yet PR:s. Only tested on amd64 based architectures like PC or NUC and Raspberry PI 3. Probably works on other architectures too. Will update the docs when I get confirmations from other platforms. The daemon is currently only distributed through Hassio add-on but a docker container and instruction to run locally will be provided in time. Please see the getting started documentation for setup. Info You need to restart the add-on every time you change a file. C# needs to compile the changes.","title":"Pre-Alpha - Expect things to change"},{"location":"#async-model","text":"The application daemon are built entirely on the async model of .NET. This requires some knowledge of async/await/Tasks to use it properly. The docs will give you tips with do and don\u00b4ts around this but I strongly suggest you read the official docs. Here is a good start to read about async model.","title":"Async model"},{"location":"license/","text":"MIT License Copyright (c) 2018 Tomas Hellstr\u00f6m Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Licence"},{"location":"API/api/","text":"NetDaemon API The netdaemon API is used to access Home Assistant features. There are a classic API and a fluent API. The project is in pre-alpha stage so the API is bound to change! It is up to the writer to decide what API suits bests their needs. Fluent API Example turn on light using the fluent API. Select entities Select one or more entities to perform any kind of actions on. Examples: await Entity ( \"light.tomas_rum_fonster\" ) . TurnOn () . WithAttribute ( \"brightness\" , 50 ) . ExecuteAsync (); The standard API Examples turn on light using the standard API using CallService or the more direct TurnOnAsync method. await await CallService ( \"light\" , \"turn_on\" , new { entity_id = \"light.tomas_rum_fonster\" , brightness = 50 }); await TurnOnAsync ( \"light.tomas_rum_fonster\" , ( \"brightness\" , 50 ));","title":"API Start"},{"location":"API/api/#netdaemon-api","text":"The netdaemon API is used to access Home Assistant features. There are a classic API and a fluent API. The project is in pre-alpha stage so the API is bound to change! It is up to the writer to decide what API suits bests their needs.","title":"NetDaemon API"},{"location":"API/api/#fluent-api","text":"Example turn on light using the fluent API.","title":"Fluent API"},{"location":"API/api/#select-entities","text":"Select one or more entities to perform any kind of actions on. Examples: await Entity ( \"light.tomas_rum_fonster\" ) . TurnOn () . WithAttribute ( \"brightness\" , 50 ) . ExecuteAsync ();","title":"Select entities"},{"location":"API/api/#the-standard-api","text":"Examples turn on light using the standard API using CallService or the more direct TurnOnAsync method. await await CallService ( \"light\" , \"turn_on\" , new { entity_id = \"light.tomas_rum_fonster\" , brightness = 50 }); await TurnOnAsync ( \"light.tomas_rum_fonster\" , ( \"brightness\" , 50 ));","title":"The standard API"},{"location":"API/Fluent/fluent_api_entities/","text":"The fluent API Entity and Entities selection To select whant entity you want to perform actions on use the Entity() or Entities() starting point. Simple selection Example 1: Selects one entity to perform action on await Entity ( \"light.light1\" ). TurnOn (). ExecuteAsync (); This selects the light.light1 to perform the TurnOn action on. A full fluent API command ends with ExecuteAsync() that execute the command now. Example 2: Selects multiple entities to perform action on Here we have several options to turn on both light1 and light2. await Entity ( \"light.light1\" , \"light.light2\" ). TurnOn (). ExecuteAsync (); This one takes a IEnumerable as input to selects multiple lights await Entities ( new string []{ \"light.light1\" , \"light.light2\" }). TurnOn (). ExecuteAsync (); Example 3: Selects multiple entities to perform action on using lambda You can also use lambda expressions to select entities like select all lights that start name with light.kitchen_ . Now it gets really interesting to use advanced selections with little code using linq. await Entities ( n => n . EntityId . StartsWith ( \"light.kitchen_\" )). TurnOn (). ExecuteAsync (); or select on attributes await Entities ( n => n . EntityId . StartsWith ( \"light.kitchen_\" )). TurnOn (). ExecuteAsync (); Special entities There are some entities that has native support in the API. MediaPlayer Media player has support for the most common service calls through the FluentAPI. Example: await MediaPlayer ( \"media_player.myplayer\" ). Play (). ExecuteAsync (); await MediaPlayer ( \"media_player.myplayer\" ). Stop (). ExecuteAsync (); await MediaPlayer ( \"media_player.myplayer\" ). PlayPause (). ExecuteAsync (); await MediaPlayer ( \"media_player.myplayer\" ). Pause (). ExecuteAsync (); The same multiple selections with IEnumerable<string> and lambdas are supported like the Entities Lambdas can be used on states and attributes too. Like stop all mediaplayers currently playing something: await MediaPlayers ( n => n . State == \"playing\" ). Stop (). ExecuteAsync (); InputSelect Todo: document input_select","title":"Entity selections"},{"location":"API/Fluent/fluent_api_entities/#the-fluent-api","text":"","title":"The fluent API"},{"location":"API/Fluent/fluent_api_entities/#entity-and-entities-selection","text":"To select whant entity you want to perform actions on use the Entity() or Entities() starting point.","title":"Entity and Entities selection"},{"location":"API/Fluent/fluent_api_entities/#simple-selection","text":"Example 1: Selects one entity to perform action on await Entity ( \"light.light1\" ). TurnOn (). ExecuteAsync (); This selects the light.light1 to perform the TurnOn action on. A full fluent API command ends with ExecuteAsync() that execute the command now. Example 2: Selects multiple entities to perform action on Here we have several options to turn on both light1 and light2. await Entity ( \"light.light1\" , \"light.light2\" ). TurnOn (). ExecuteAsync (); This one takes a IEnumerable as input to selects multiple lights await Entities ( new string []{ \"light.light1\" , \"light.light2\" }). TurnOn (). ExecuteAsync (); Example 3: Selects multiple entities to perform action on using lambda You can also use lambda expressions to select entities like select all lights that start name with light.kitchen_ . Now it gets really interesting to use advanced selections with little code using linq. await Entities ( n => n . EntityId . StartsWith ( \"light.kitchen_\" )). TurnOn (). ExecuteAsync (); or select on attributes await Entities ( n => n . EntityId . StartsWith ( \"light.kitchen_\" )). TurnOn (). ExecuteAsync ();","title":"Simple selection"},{"location":"API/Fluent/fluent_api_entities/#special-entities","text":"There are some entities that has native support in the API.","title":"Special entities"},{"location":"API/Fluent/fluent_api_entities/#mediaplayer","text":"Media player has support for the most common service calls through the FluentAPI. Example: await MediaPlayer ( \"media_player.myplayer\" ). Play (). ExecuteAsync (); await MediaPlayer ( \"media_player.myplayer\" ). Stop (). ExecuteAsync (); await MediaPlayer ( \"media_player.myplayer\" ). PlayPause (). ExecuteAsync (); await MediaPlayer ( \"media_player.myplayer\" ). Pause (). ExecuteAsync (); The same multiple selections with IEnumerable<string> and lambdas are supported like the Entities Lambdas can be used on states and attributes too. Like stop all mediaplayers currently playing something: await MediaPlayers ( n => n . State == \"playing\" ). Stop (). ExecuteAsync ();","title":"MediaPlayer"},{"location":"API/Fluent/fluent_api_entities/#inputselect","text":"Todo: document input_select","title":"InputSelect"},{"location":"API/Fluent/fluent_api_state/","text":"The fluent API Basic state management The fluent API lets you easily subscribe to state changes. Let\u00b4s start with a very basic example. If the motion sensors state turns to \"on\", turn on the light.light1 light. Here we do not use ExecuteAsync since the setup is a synchronous function ( Execute ). The WhenStateChange method makes sure we subscribe to the specific state changes from anything to state \"on\" . Entity ( \"binary_sensor.my_motion_sensor\" ). WhenStateChange ( to : \"on\" ). UseEntity ( \"light.light1\" ). TurnOn (). Execute (); If the from state is important then use it like: Entity ( \"binary_sensor.my_motion_sensor\" ). WhenStateChange ( from : \"off\" , to : \"on\" ). UseEntity ( \"light.light1\" ). TurnOn (). Execute (); You can also use lambda expressions to select state changes: Entity ( \"binary_sensor.my_motion_sensor\" ). WhenStateChange (( toState , fromState ) => toState ?. State == \"on\" ). UseEntity ( \"light.light1\" ). TurnOn (). Execute (); Or even more advanced example. You can use any combination of state and attributes or even external methods i lambda expressions. Here is an example: When sun elevation below 3.0 and not rising and old state elevation is above 3.0 then we should turn on light. Entity ( \"sun.sun\" ) . WhenStateChange (( n , o ) => n ?. Attribute ?. elevation <= 3.0 && n ?. Attribute ?. rising == false && o ?. Attribute ?. elevation > 3.0 ). UseEntity ( \"light.light1\" ). TurnOn (). Execute (); if you rather call a function when a state changes you can use Func<> for that like the example below. Entity ( \"binary_sensor.my_motion_sensor\" ). WhenStateChange ( to : \"on\" ). Call ( async ( entityId , newState , oldState ) => { await Entity ( \"light.light1\" ). TurnOn (). ExecuteAsync (); }). Execute (); If you prefer to call a method you can use following syntax: Entity ( \"binary_sensor.my_motion_sensor\" ). WhenStateChange ( to : \"on\" ). Call ( MyMotionSensorStateChange ). Execute (); And the method for state changes looks like: private async Task MyMotionSensorStateChange ( string entityId , EntityState ? newState , EntityState ? oldState ) { await Entity ( \"light.light1\" ). TurnOn (). ExecuteAsync (); }","title":"State changes"},{"location":"API/Fluent/fluent_api_state/#the-fluent-api","text":"","title":"The fluent API"},{"location":"API/Fluent/fluent_api_state/#basic-state-management","text":"The fluent API lets you easily subscribe to state changes. Let\u00b4s start with a very basic example. If the motion sensors state turns to \"on\", turn on the light.light1 light. Here we do not use ExecuteAsync since the setup is a synchronous function ( Execute ). The WhenStateChange method makes sure we subscribe to the specific state changes from anything to state \"on\" . Entity ( \"binary_sensor.my_motion_sensor\" ). WhenStateChange ( to : \"on\" ). UseEntity ( \"light.light1\" ). TurnOn (). Execute (); If the from state is important then use it like: Entity ( \"binary_sensor.my_motion_sensor\" ). WhenStateChange ( from : \"off\" , to : \"on\" ). UseEntity ( \"light.light1\" ). TurnOn (). Execute (); You can also use lambda expressions to select state changes: Entity ( \"binary_sensor.my_motion_sensor\" ). WhenStateChange (( toState , fromState ) => toState ?. State == \"on\" ). UseEntity ( \"light.light1\" ). TurnOn (). Execute (); Or even more advanced example. You can use any combination of state and attributes or even external methods i lambda expressions. Here is an example: When sun elevation below 3.0 and not rising and old state elevation is above 3.0 then we should turn on light. Entity ( \"sun.sun\" ) . WhenStateChange (( n , o ) => n ?. Attribute ?. elevation <= 3.0 && n ?. Attribute ?. rising == false && o ?. Attribute ?. elevation > 3.0 ). UseEntity ( \"light.light1\" ). TurnOn (). Execute (); if you rather call a function when a state changes you can use Func<> for that like the example below. Entity ( \"binary_sensor.my_motion_sensor\" ). WhenStateChange ( to : \"on\" ). Call ( async ( entityId , newState , oldState ) => { await Entity ( \"light.light1\" ). TurnOn (). ExecuteAsync (); }). Execute (); If you prefer to call a method you can use following syntax: Entity ( \"binary_sensor.my_motion_sensor\" ). WhenStateChange ( to : \"on\" ). Call ( MyMotionSensorStateChange ). Execute (); And the method for state changes looks like: private async Task MyMotionSensorStateChange ( string entityId , EntityState ? newState , EntityState ? oldState ) { await Entity ( \"light.light1\" ). TurnOn (). ExecuteAsync (); }","title":"Basic state management"},{"location":"API/Standard API/standard_api_get_state/","text":"The fluent API Get State of an entity The method for getting state is using the State dictionary. It is thread safe dictionary containing all states in Home Assistant. All states are read at start-up and kept in sync by the netdaemon. This means that getting current state does not make a network call to Home Assistant that in most cases will be cached value. This is very efficient performance wise and will be sufficient in most cases. There might me an API addition in the future that let you get the value from the server directly. Basic example getting state: Using the new nullable features in c# 8 you can easily get state or null (no state found) string? state = GetState ( \"light.light1\" )?. State ; if ( state != null ) { ... } Or get all information from the entity state: string? entityState = GetState ( \"light.light1\" ); if ( entityState != null ) { var entityId = entityState . EntityId ; var state = entityState . State ; var brightness = entityState ?. Attribute ?. brightness ; var lastUpdated = entityState ?. LastUpdated ; //DateTime in local time var lastChanged = entityState ?. LastChanged ; //DateTime in local time }","title":"Get state"},{"location":"API/Standard API/standard_api_get_state/#the-fluent-api","text":"","title":"The fluent API"},{"location":"API/Standard API/standard_api_get_state/#get-state-of-an-entity","text":"The method for getting state is using the State dictionary. It is thread safe dictionary containing all states in Home Assistant. All states are read at start-up and kept in sync by the netdaemon. This means that getting current state does not make a network call to Home Assistant that in most cases will be cached value. This is very efficient performance wise and will be sufficient in most cases. There might me an API addition in the future that let you get the value from the server directly. Basic example getting state: Using the new nullable features in c# 8 you can easily get state or null (no state found) string? state = GetState ( \"light.light1\" )?. State ; if ( state != null ) { ... } Or get all information from the entity state: string? entityState = GetState ( \"light.light1\" ); if ( entityState != null ) { var entityId = entityState . EntityId ; var state = entityState . State ; var brightness = entityState ?. Attribute ?. brightness ; var lastUpdated = entityState ?. LastUpdated ; //DateTime in local time var lastChanged = entityState ?. LastChanged ; //DateTime in local time }","title":"Get State of an entity"},{"location":"Getting started/1_getting started/","text":"Installation Install the Hass.io add-on Add the https://github.com/helto4real/hassio-add-ons in Add new repository URL to the add-on store. Add the NetDaemon add-on. After you install it, do not start it just yet. We need to configure some stuff manually (will be improved as we come closer to release) Download the development environment Development of apps is currently recommended doing locally. A vscode development devcontainer has been prepared for you at https://github.com/helto4real/netdaemon-app-template . Use the GitHub template for your own project. The folder should be containing the following files: Open the content in vscode Make sure you installed Remote Development extension in vscode Open the netdaemon folder and select open as container. Wait for the container to be created. Configure the daemon_config.json properly Open the vscode terminal and run dotnet restore , this needs to be done to get intellisense to work properly. Sometimes you need to restart vscode once for it to work. Hack away! Run and debug your stuff! There are a few code snippets (ctrl+space) you can use. There will be more later. Deploy your apps After you have developed and tested you app you want to copy the whole app to the config folder. The new folder structure should be /config/netdaemon/apps where /config is the path to your Home Assistant config. Start the add-on Now you can start the plugin, check the logs for any errors. IMPORTANT - YOU NEED TO RESTART THE ADD-ON EVERYTIME YOU MAKE CHANGES TO A FILE SINCE C# COMPILES Check out the examples in docs Todo: make link to examples here.. My own automations can be found at : https://github.com/helto4real/hassio/tree/master/netdaemon/apps .","title":"Installation"},{"location":"Getting started/1_getting started/#installation","text":"","title":"Installation"},{"location":"Getting started/1_getting started/#install-the-hassio-add-on","text":"Add the https://github.com/helto4real/hassio-add-ons in Add new repository URL to the add-on store. Add the NetDaemon add-on. After you install it, do not start it just yet. We need to configure some stuff manually (will be improved as we come closer to release)","title":"Install the Hass.io add-on"},{"location":"Getting started/1_getting started/#download-the-development-environment","text":"Development of apps is currently recommended doing locally. A vscode development devcontainer has been prepared for you at https://github.com/helto4real/netdaemon-app-template . Use the GitHub template for your own project. The folder should be containing the following files:","title":"Download the development environment"},{"location":"Getting started/1_getting started/#open-the-content-in-vscode","text":"Make sure you installed Remote Development extension in vscode Open the netdaemon folder and select open as container. Wait for the container to be created. Configure the daemon_config.json properly Open the vscode terminal and run dotnet restore , this needs to be done to get intellisense to work properly. Sometimes you need to restart vscode once for it to work. Hack away! Run and debug your stuff! There are a few code snippets (ctrl+space) you can use. There will be more later.","title":"Open the content in vscode"},{"location":"Getting started/1_getting started/#deploy-your-apps","text":"After you have developed and tested you app you want to copy the whole app to the config folder. The new folder structure should be /config/netdaemon/apps where /config is the path to your Home Assistant config.","title":"Deploy your apps"},{"location":"Getting started/1_getting started/#start-the-add-on","text":"Now you can start the plugin, check the logs for any errors. IMPORTANT - YOU NEED TO RESTART THE ADD-ON EVERYTIME YOU MAKE CHANGES TO A FILE SINCE C# COMPILES","title":"Start the add-on"},{"location":"Getting started/1_getting started/#check-out-the-examples-in-docs","text":"Todo: make link to examples here.. My own automations can be found at : https://github.com/helto4real/hassio/tree/master/netdaemon/apps .","title":"Check out the examples in docs"},{"location":"Getting started/2_basics/","text":"Basics The file structure All automation files is in the netdaemon folder directly under your configuration folder. Typically you access these files within vscode or any other editor. This should be your root directory on you hassio share in vscode: Get intellisense Before coding, run the dotnet restore to get intellisense. Create new app Automations in NetDaemon is created in apps. All apps inherit from the base class NetDaemonApp . All apps have to implement and override the function: public async override Task InitializeAsync () This function is called by the daemon at start up. Never block this function! Make sure you run your initializations and return. Example of an initialization using the fluent API: public async override Task InitializeAsync () { Entity ( \"binary_sensor.my_pir\" ) . WhenStateChange () . Call ( OnPirChanged ) . Execute (); } This initialize the app to call a function called OnPirChanged when ever the entity binary_sensor.my_pir change state. More of this in the example app. Code snippets I provide some code snippets to create a new app. Check it out.. In vscode, in the c# code file press ctrl+space and select.. More will come later. Async model NetDaemon is built on .NET and c# async model. It is important that you read up on async programming model. But here is some basics! Use the await keyword Whenever you see a function return a Task and mostly these functions has the postfix Async . Use the keyword await before calling. Example using the fluent API below: private async Task MyAsyncFunctionDoingStuff () { await MediaPlayer ( \"media_player.cool_player\" ) . Pause (). ExecuteAsync (); } Remember that the function needs to be async containing this call as the example shows. Do not use Thread.Sleep() Danger Never use Thread.Sleep(); ! It is very important that you never block async operations. Use the await Task.Delay(); instead if you need to pause execution.","title":"Basics"},{"location":"Getting started/2_basics/#basics","text":"","title":"Basics"},{"location":"Getting started/2_basics/#the-file-structure","text":"All automation files is in the netdaemon folder directly under your configuration folder. Typically you access these files within vscode or any other editor. This should be your root directory on you hassio share in vscode:","title":"The file structure"},{"location":"Getting started/2_basics/#get-intellisense","text":"Before coding, run the dotnet restore to get intellisense.","title":"Get intellisense"},{"location":"Getting started/2_basics/#create-new-app","text":"Automations in NetDaemon is created in apps. All apps inherit from the base class NetDaemonApp . All apps have to implement and override the function: public async override Task InitializeAsync () This function is called by the daemon at start up. Never block this function! Make sure you run your initializations and return. Example of an initialization using the fluent API: public async override Task InitializeAsync () { Entity ( \"binary_sensor.my_pir\" ) . WhenStateChange () . Call ( OnPirChanged ) . Execute (); } This initialize the app to call a function called OnPirChanged when ever the entity binary_sensor.my_pir change state. More of this in the example app.","title":"Create new app"},{"location":"Getting started/2_basics/#code-snippets","text":"I provide some code snippets to create a new app. Check it out.. In vscode, in the c# code file press ctrl+space and select.. More will come later.","title":"Code snippets"},{"location":"Getting started/2_basics/#async-model","text":"NetDaemon is built on .NET and c# async model. It is important that you read up on async programming model. But here is some basics!","title":"Async model"},{"location":"Getting started/2_basics/#use-the-await-keyword","text":"Whenever you see a function return a Task and mostly these functions has the postfix Async . Use the keyword await before calling. Example using the fluent API below: private async Task MyAsyncFunctionDoingStuff () { await MediaPlayer ( \"media_player.cool_player\" ) . Pause (). ExecuteAsync (); } Remember that the function needs to be async containing this call as the example shows.","title":"Use the await keyword"},{"location":"Getting started/2_basics/#do-not-use-threadsleep","text":"Danger Never use Thread.Sleep(); ! It is very important that you never block async operations. Use the await Task.Delay(); instead if you need to pause execution.","title":"Do not use Thread.Sleep()"},{"location":"Getting started/3_example app/","text":"Example app This application shows basic capabilities of the fluent API of NetDaemon. It has two files, ExampleApp.yaml that contains basic configuration of the instance and ExampleApp.cs that contains the app logic. ExampleApp.yaml example_app : class : ExampleApp ExampleApp.cs using System ; using System.Threading.Tasks ; using JoySoftware.HomeAssistant.NetDaemon.Common ; /// <summary> /// Example app /// </summary> public class ExampleApp : NetDaemonApp { public override async Task InitializeAsync () { Entity ( \"binary_sensor.kitchen_pir\" ) . WhenStateChange ( to : \"on\" ) . UseEntity ( \"light.kitchen_light\" ) . TurnOn () . Execute (); Entity ( \"binary_sensor.kitchen_pir\" ) . WhenStateChange ( to : \"off\" ) . AndNotChangeFor ( TimeSpan . FromMinutes ( 10 )) . UseEntity ( \"light.kitchen_light\" ) . TurnOff () . Execute (); } } The NetDaemonApp base class public class ExampleApp : NetDaemonApp All applications in netdaemon have to inherit the NetDaemonApp base class. This provides discoverability and functionality to the application. The InitializeAsync function public override async Task InitializeAsync () This async function is called by the daemon and it\u00b4s purpose is to do all the initialization of your application. Never block this function! Typically you configure what should happen when a state change or run a function every minute for an example. Example: Entity ( \"binary_sensor.kitchen_pir\" ) . WhenStateChange ( to : \"off\" ) . AndNotChangeFor ( TimeSpan . FromMinutes ( 10 )) . UseEntity ( \"light.kitchen_light\" ) . TurnOff () . Execute (); Function Description Entity Selects one or more entities where actions are applied WhenStateChange If state changes on previously defined entity do action AndNotChangeFor Do action only if state has not change for a period of time (10 minutes) UseEntity The action on previously selected entity/ies TurnOff The action on previously selected entity/ies Execute Ends the api call. You cannot skip this function or the automation will not be activated! Real-world example apps Please check out the apps being developed for netdaemon. Since documentation is still lacking behind it will be best looking at real code \ud83d\ude0a User Description @helto4real My own netdaemon apps running in production @isabellaalstrom Isabella's netdaemon apps, check them out, nice stuff","title":"Example app"},{"location":"Getting started/3_example app/#example-app","text":"This application shows basic capabilities of the fluent API of NetDaemon. It has two files, ExampleApp.yaml that contains basic configuration of the instance and ExampleApp.cs that contains the app logic.","title":"Example app"},{"location":"Getting started/3_example app/#exampleappyaml","text":"example_app : class : ExampleApp","title":"ExampleApp.yaml"},{"location":"Getting started/3_example app/#exampleappcs","text":"using System ; using System.Threading.Tasks ; using JoySoftware.HomeAssistant.NetDaemon.Common ; /// <summary> /// Example app /// </summary> public class ExampleApp : NetDaemonApp { public override async Task InitializeAsync () { Entity ( \"binary_sensor.kitchen_pir\" ) . WhenStateChange ( to : \"on\" ) . UseEntity ( \"light.kitchen_light\" ) . TurnOn () . Execute (); Entity ( \"binary_sensor.kitchen_pir\" ) . WhenStateChange ( to : \"off\" ) . AndNotChangeFor ( TimeSpan . FromMinutes ( 10 )) . UseEntity ( \"light.kitchen_light\" ) . TurnOff () . Execute (); } }","title":"ExampleApp.cs"},{"location":"Getting started/3_example app/#the-netdaemonapp-base-class","text":"public class ExampleApp : NetDaemonApp All applications in netdaemon have to inherit the NetDaemonApp base class. This provides discoverability and functionality to the application.","title":"The NetDaemonApp base class"},{"location":"Getting started/3_example app/#the-initializeasync-function","text":"public override async Task InitializeAsync () This async function is called by the daemon and it\u00b4s purpose is to do all the initialization of your application. Never block this function! Typically you configure what should happen when a state change or run a function every minute for an example. Example: Entity ( \"binary_sensor.kitchen_pir\" ) . WhenStateChange ( to : \"off\" ) . AndNotChangeFor ( TimeSpan . FromMinutes ( 10 )) . UseEntity ( \"light.kitchen_light\" ) . TurnOff () . Execute (); Function Description Entity Selects one or more entities where actions are applied WhenStateChange If state changes on previously defined entity do action AndNotChangeFor Do action only if state has not change for a period of time (10 minutes) UseEntity The action on previously selected entity/ies TurnOff The action on previously selected entity/ies Execute Ends the api call. You cannot skip this function or the automation will not be activated!","title":"The InitializeAsync function"},{"location":"Getting started/3_example app/#real-world-example-apps","text":"Please check out the apps being developed for netdaemon. Since documentation is still lacking behind it will be best looking at real code \ud83d\ude0a User Description @helto4real My own netdaemon apps running in production @isabellaalstrom Isabella's netdaemon apps, check them out, nice stuff","title":"Real-world example apps"}]}